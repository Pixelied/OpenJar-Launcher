name: release

on:
  push:
    tags:
      - "v*.*.*"

permissions:
  contents: write

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build:
    name: Build (${{ matrix.label }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-15-intel
            label: macos-intel
            target: x86_64-apple-darwin

          - os: macos-15
            label: macos-arm64
            target: aarch64-apple-darwin

          - os: windows-latest
            label: windows
            target: x86_64-pc-windows-msvc

          - os: windows-latest
            label: windows-arm64
            target: aarch64-pc-windows-msvc

          - os: ubuntu-22.04
            label: linux
            target: x86_64-unknown-linux-gnu

    env:
      CI: "true"
      MPM_CURSEFORGE_API_KEY_BUILTIN: ${{ secrets.MPM_CURSEFORGE_API_KEY_BUILTIN }}
      TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
      TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
      TAURI_UPDATER_PUBKEY: ${{ secrets.TAURI_UPDATER_PUBKEY }}
      TAURI_UPDATER_PUBLIC_KEY: ${{ secrets.TAURI_UPDATER_PUBLIC_KEY }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node 20 (npm cache)
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install Linux system dependencies (Tauri/WebKitGTK/libsoup2)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            build-essential \
            pkg-config \
            libssl-dev \
            libgtk-3-dev \
            libwebkit2gtk-4.0-dev \
            libsoup2.4-dev \
            libjavascriptcoregtk-4.0-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf \
            curl \
            wget \
            file
          pkg-config --modversion libsoup-2.4
          pkg-config --modversion webkit2gtk-4.0

      - name: Disable DMG bundling on macOS (ship zipped .app + updater artifacts)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail
          CONF=""
          if [ -f "src-tauri/tauri.conf.json" ]; then CONF="src-tauri/tauri.conf.json"; fi
          if [ -f "src-tauri/tauri.conf.json5" ]; then CONF="src-tauri/tauri.conf.json5"; fi
          if [ -z "$CONF" ]; then
            echo "No tauri.conf.json/json5 found; skipping patch."
            exit 0
          fi
          echo "Patching $CONF to disable DMG (set bundle.targets to [\"app\", \"updater\"])."
          # Best-effort patch that works for common JSON/JSON5 shapes without requiring json5 tooling:
          # 1) If targets is an array, replace its contents with app + updater
          # 2) If targets is a string (e.g., "all"), set it to ["app", "updater"]
          perl -0777 -i -pe '
            s/"targets"\s*:\s*\[[^\]]*\]/"targets": ["app", "updater"]/g;
            s/"targets"\s*:\s*"all"/"targets": ["app", "updater"]/g;
            s/"targets"\s*:\s*"dmg"/"targets": ["app", "updater"]/g;
          ' "$CONF"

      - name: Setup Rust (stable) + target
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Validate updater signing secrets
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${TAURI_PRIVATE_KEY:-}" ]; then
            echo "Missing TAURI_PRIVATE_KEY secret. Updater bundles require signing."
            exit 1
          fi
          if [ -z "${TAURI_UPDATER_PUBKEY:-}${TAURI_UPDATER_PUBLIC_KEY:-}" ]; then
            echo "Missing TAURI_UPDATER_PUBKEY/TAURI_UPDATER_PUBLIC_KEY secret. Release binaries must embed updater pubkey."
            exit 1
          fi

      - name: Normalize updater keys for release build
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .tauri-ci
          node <<'NODE'
          const fs = require("fs");
          const path = require("path");
          const confPath = "src-tauri/tauri.conf.json";

          const stripWrapping = (input) => {
            let s = String(input || "").trim();
            if (
              (s.startsWith('"') && s.endsWith('"')) ||
              (s.startsWith("'") && s.endsWith("'")) ||
              (s.startsWith("`") && s.endsWith("`"))
            ) {
              s = s.slice(1, -1).trim();
            }
            return s;
          };

          const decodeUriSafely = (input) => {
            const safeInput = String(input || "").replace(/%(?![0-9A-Fa-f]{2})/g, "%25");
            try {
              return decodeURIComponent(safeInput);
            } catch {
              return input;
            }
          };

          const decodeBase64Variants = (input) => {
            const compact = String(input || "").replace(/\s+/g, "");
            if (!compact || compact.length < 8) return [];
            const candidates = new Set();
            const addWithPadding = (value) => {
              if (!value) return;
              if (!/^[A-Za-z0-9+/=]+$/.test(value)) return;
              candidates.add(value);
              const rem = value.length % 4;
              if (rem !== 0) candidates.add(`${value}${"=".repeat(4 - rem)}`);
            };
            const addVariants = (value) => {
              if (!value) return;
              addWithPadding(value);
              addWithPadding(value.replace(/-/g, "+").replace(/_/g, "/"));
            };

            addVariants(compact);
            const marker = compact.match(/base64[:,]/i);
            if (marker) {
              addVariants(compact.slice(marker.index + marker[0].length));
            }

            const tokenMatches = compact.match(/[A-Za-z0-9+/_=-]{16,}/g) || [];
            for (const token of tokenMatches) {
              addVariants(token);
            }

            const out = [];
            for (const variant of candidates) {
              try {
                const decoded = Buffer.from(variant, "base64").toString("utf8");
                if (!decoded || !decoded.trim()) continue;
                out.push(decoded);
              } catch {}
            }
            return out;
          };

          const normalizeText = (input) => {
            let s = stripWrapping(input);
            s = s.replace(/\\r\\n/g, "\n").replace(/\\n/g, "\n").replace(/\\r/g, "\n");
            s = decodeUriSafely(s);
            return stripWrapping(s).trim();
          };

          const buildCandidates = (raw) => {
            const seen = new Set();
            const queue = [normalizeText(raw)];
            const out = [];
            while (queue.length) {
              const cur = normalizeText(queue.shift());
              if (!cur || seen.has(cur)) continue;
              seen.add(cur);
              out.push(cur);
              if (out.length > 16) break;
              const uri = normalizeText(decodeUriSafely(cur));
              if (uri && !seen.has(uri)) queue.push(uri);
              for (const decoded of decodeBase64Variants(cur)) {
                const next = normalizeText(decoded);
                if (next && !seen.has(next)) queue.push(next);
              }
            }
            return out;
          };

          const extractPubKey = (raw) => {
            for (const attempt of buildCandidates(raw)) {
              const lines = attempt
                .split(/\r?\n/)
                .map((line) => line.trim())
                .filter(Boolean);
              const lineHit = lines
                .map((line) => line.match(/RW[A-Za-z0-9+/_=-]{20,}/))
                .find(Boolean);
              if (lineHit) return lineHit[0];
              const inlineHit = attempt.match(/RW[A-Za-z0-9+/_=-]{20,}/);
              if (inlineHit) return inlineHit[0];
            }
            return "";
          };

          const extractPrivateKey = (raw) => {
            return (
              buildCandidates(raw).find((entry) =>
                entry.includes("untrusted comment: minisign secret key:")
              ) || ""
            );
          };

          const rawPub = process.env.TAURI_UPDATER_PUBKEY || process.env.TAURI_UPDATER_PUBLIC_KEY || "";
          const parsedPub = extractPubKey(rawPub);
          const pub = parsedPub.replace(/-/g, "+").replace(/_/g, "/");
          if (!pub || !/^RW[A-Za-z0-9+/=]+$/.test(pub)) {
            const preview = normalizeText(rawPub).slice(0, 48);
            throw new Error(
              `Could not parse updater pubkey. Expected minisign public key line starting with RW. Got prefix: "${preview}".`
            );
          }

          const rawPriv = process.env.TAURI_PRIVATE_KEY || "";
          const priv = extractPrivateKey(rawPriv);
          if (!priv) {
            throw new Error("Could not parse TAURI_PRIVATE_KEY into minisign secret key content.");
          }

          const privateKeyPath = path.join(".tauri-ci", "updater.private.key");
          fs.writeFileSync(privateKeyPath, `${priv}\n`, "utf8");
          fs.chmodSync(privateKeyPath, 0o600);
          fs.appendFileSync(process.env.GITHUB_ENV, `TAURI_PRIVATE_KEY=${privateKeyPath}\n`, "utf8");

          const config = JSON.parse(fs.readFileSync(confPath, "utf8"));
          config.tauri = config.tauri || {};
          config.tauri.updater = config.tauri.updater || {};
          config.tauri.updater.pubkey = pub;
          fs.writeFileSync(confPath, `${JSON.stringify(config, null, 2)}\n`, "utf8");
          console.log("Normalized updater key material and injected updater pubkey.");
          NODE

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            src-tauri -> target

      - name: Install JS deps
        run: npm ci

      - name: Build (Tauri)
        shell: bash
        run: |
          set -euxo pipefail
          npm run tauri:build -- --target ${{ matrix.target }}

      - name: Ad-hoc sign macOS app (avoids "damaged" warning)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euxo pipefail
          BUNDLE_DIR="src-tauri/target/${{ matrix.target }}/release/bundle/macos"

          echo "Looking for .app in: $BUNDLE_DIR"
          ls -la "$BUNDLE_DIR" || true

          APP="$(ls -d "$BUNDLE_DIR"/*.app 2>/dev/null | head -n 1)"
          if [ -z "${APP:-}" ]; then
            echo "No .app found at expected path."
            echo "Searching bundle dir for any .app..."
            find "src-tauri/target/${{ matrix.target }}/release/bundle" -maxdepth 4 -name "*.app" -print || true
            exit 1
          fi

          echo "Signing: $APP"
          codesign --force --deep --sign - "$APP"
          codesign --verify --deep --strict "$APP"


      - name: Collect release artifacts
        shell: bash
        run: |
          set -euxo pipefail
          mkdir -p dist-artifacts

          TAG="${GITHUB_REF_NAME}"
          LABEL="${{ matrix.label }}"

          BUNDLE_DIR_1="src-tauri/target/${{ matrix.target }}/release/bundle"
          BUNDLE_DIR_2="src-tauri/target/release/bundle"

          pick_bundle_dir() {
            if [ -d "$BUNDLE_DIR_1" ]; then echo "$BUNDLE_DIR_1"; return; fi
            if [ -d "$BUNDLE_DIR_2" ]; then echo "$BUNDLE_DIR_2"; return; fi
            local found
            found="$(find "src-tauri/target" -type d -path "*/release/bundle" | head -n 1 || true)"
            if [ -n "$found" ]; then echo "$found"; return; fi
            echo ""
          }

          BUNDLE_DIR="$(pick_bundle_dir)"
          if [ -z "$BUNDLE_DIR" ]; then
            echo "Could not find Tauri bundle directory."
            echo "Tried: $BUNDLE_DIR_1 and $BUNDLE_DIR_2"
            exit 1
          fi

          echo "Using bundle dir: $BUNDLE_DIR"

          shopt -s nullglob

          if [ "${{ runner.os }}" = "macOS" ]; then
            APPS=("$BUNDLE_DIR/macos/"*.app)
            if [ "${#APPS[@]}" -lt 1 ]; then
              echo "No .app found in $BUNDLE_DIR/macos"
              find "$BUNDLE_DIR" -maxdepth 4 -type d -name "*.app" -print || true
              exit 1
            fi
            APP="${APPS[0]}"
            APP_BASENAME="$(basename "$APP" .app)"
            OUT="dist-artifacts/${APP_BASENAME}_${TAG}_${LABEL}.app.zip"
            ditto -c -k --sequesterRsrc --keepParent "$APP" "$OUT"
            echo "Created: $OUT"
          elif [ "${{ runner.os }}" = "Windows" ]; then
            for f in \
              "$BUNDLE_DIR"/msi/*.msi \
              "$BUNDLE_DIR"/nsis/*.exe \
              "$BUNDLE_DIR"/windows/*.msi \
              "$BUNDLE_DIR"/windows/*.exe
            do
              if [ -f "$f" ]; then
                base="$(basename "$f")"
                ext="${base##*.}"
                stem="${base%.*}"
                cp -f "$f" "dist-artifacts/${stem}_${TAG}_${LABEL}.${ext}"
              fi
            done
          else
            for f in \
              "$BUNDLE_DIR"/appimage/*.AppImage \
              "$BUNDLE_DIR"/deb/*.deb \
              "$BUNDLE_DIR"/rpm/*.rpm
            do
              if [ -f "$f" ]; then
                base="$(basename "$f")"
                ext="${base##*.}"
                stem="${base%.*}"
                cp -f "$f" "dist-artifacts/${stem}_${TAG}_${LABEL}.${ext}"
              fi
            done
          fi

          # Keep updater artifacts when present.
          while IFS= read -r -d '' f; do
            base="$(basename "$f")"
            if [[ "$base" == *.tar.gz.sig ]]; then
              out="${base%.tar.gz.sig}_${TAG}_${LABEL}.tar.gz.sig"
            elif [[ "$base" == *.tar.gz ]]; then
              out="${base%.tar.gz}_${TAG}_${LABEL}.tar.gz"
            elif [[ "$base" == *.zip.sig ]]; then
              out="${base%.zip.sig}_${TAG}_${LABEL}.zip.sig"
            elif [[ "$base" == *.zip ]]; then
              out="${base%.zip}_${TAG}_${LABEL}.zip"
            elif [[ "$base" == *.sig ]]; then
              out="${base%.sig}_${TAG}_${LABEL}.sig"
            else
              ext="${base##*.}"
              stem="${base%.*}"
              out="${stem}_${TAG}_${LABEL}.${ext}"
            fi
            cp -f "$f" "dist-artifacts/$out"
          done < <(find "$BUNDLE_DIR" -type f \( -name "*.sig" -o -name "*.tar.gz" -o -name "*.zip" \) -print0)

          # Sanity: only keep real distributables
          find dist-artifacts -type f \
            ! -name "*.dmg" \
            ! -name "*.zip" \
            ! -name "*.tar.gz" \
            ! -name "*.AppImage" \
            ! -name "*.deb" \
            ! -name "*.rpm" \
            ! -name "*.msi" \
            ! -name "*.exe" \
            ! -name "*.sig" \
            -delete || true

          echo "Final artifacts:"
          ls -la dist-artifacts
          test -n "$(ls -A dist-artifacts)"

      - name: Upload workflow artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.label }}
          path: dist-artifacts/*
          if-no-files-found: error
          retention-days: 7

  publish:
    name: Publish GitHub Release
    runs-on: ubuntu-latest
    needs: build
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-assets

      - name: List assets
        shell: bash
        run: |
          set -euxo pipefail
          find release-assets -type f -maxdepth 3 -print
          test -n "$(find release-assets -type f -maxdepth 3 -print -quit)"

      - name: Generate latest.json updater manifest
        shell: bash
        run: |
          set -euo pipefail
          node -e 'const fs=require("fs"); const path=require("path"); const root="release-assets"; const repo=process.env.GITHUB_REPOSITORY; const tag=process.env.GITHUB_REF_NAME; if(!repo||!tag){ throw new Error("Missing GITHUB_REPOSITORY or GITHUB_REF_NAME"); } const version=tag.startsWith("v")?tag.slice(1):tag; const walk=(dir)=>{ const out=[]; for (const item of fs.readdirSync(dir,{withFileTypes:true})) { const full=path.join(dir,item.name); if(item.isDirectory()) out.push(...walk(full)); else if(item.isFile()) out.push(full); } return out; }; const files=walk(root).map((full)=>path.relative(root,full).replace(/\\\\/g,"/")); const updaterArchives=files.filter((f)=>f.endsWith(".tar.gz")||f.endsWith(".zip")); const platforms={}; const detectPlatform=(fileName)=>{ if(fileName.includes("_macos-arm64.tar.gz")) return "darwin-aarch64"; if(fileName.includes("_macos-intel.tar.gz")) return "darwin-x86_64"; if(fileName.includes("_windows-arm64.tar.gz")||fileName.includes("_windows-arm64.zip")) return "windows-aarch64"; if(fileName.includes("_windows-x64.tar.gz")||fileName.includes("_windows.tar.gz")) return "windows-x86_64"; if(fileName.includes("_windows-x64.zip")||fileName.includes("_windows.zip")) return "windows-x86_64"; if(fileName.includes("_linux-x64.tar.gz")||fileName.includes("_linux.tar.gz")) return "linux-x86_64"; return null; }; for (const archive of updaterArchives) { const platform=detectPlatform(archive); if(!platform) continue; const sigPath=archive+".sig"; const fullSig=path.join(root,sigPath); if(!fs.existsSync(fullSig)) continue; const signature=fs.readFileSync(fullSig,"utf8").trim(); if(!signature) continue; const fileName=path.basename(archive); const encodedFileName=encodeURIComponent(fileName); platforms[platform]={ signature, url:"https://github.com/"+repo+"/releases/download/"+tag+"/"+encodedFileName }; } if (Object.keys(platforms).length===0) { throw new Error("No signed updater artifacts found for latest.json generation."); } const manifest={ version, notes:"OpenJar Launcher "+tag, pub_date:new Date().toISOString(), platforms }; const outPath=path.join(root,"latest.json"); fs.writeFileSync(outPath, JSON.stringify(manifest,null,2)+"\\n","utf8"); console.log("Wrote "+outPath); console.log(JSON.stringify(manifest,null,2));'

      - name: Create/Update GitHub Release and upload assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          generate_release_notes: true
          fail_on_unmatched_files: true
          files: |
            release-assets/**/*.zip
            release-assets/**/*.tar.gz
            release-assets/**/*.AppImage
            release-assets/**/*.deb
            release-assets/**/*.rpm
            release-assets/**/*.msi
            release-assets/**/*.exe
            release-assets/**/*.sig
            release-assets/latest.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
