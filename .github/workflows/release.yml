name: release

on:
  push:
    tags:
      - "v*.*.*"

permissions:
  contents: write

concurrency:
  group: release-${{ github.ref }}
  cancel-in-progress: false

jobs:
  build:
    name: Build (${{ matrix.label }})
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        include:
          - os: macos-15-intel
            label: macos-intel
            target: x86_64-apple-darwin

          - os: macos-15
            label: macos-arm64
            target: aarch64-apple-darwin

          - os: windows-latest
            label: windows
            target: x86_64-pc-windows-msvc

          - os: windows-latest
            label: windows-arm64
            target: aarch64-pc-windows-msvc

          - os: ubuntu-22.04
            label: linux
            target: x86_64-unknown-linux-gnu

    env:
      CI: "true"
      MPM_CURSEFORGE_API_KEY_BUILTIN: ${{ secrets.MPM_CURSEFORGE_API_KEY_BUILTIN }}
      TAURI_PRIVATE_KEY: ${{ secrets.TAURI_PRIVATE_KEY }}
      TAURI_KEY_PASSWORD: ${{ secrets.TAURI_KEY_PASSWORD }}
      TAURI_UPDATER_PUBKEY: ${{ secrets.TAURI_UPDATER_PUBKEY }}
      TAURI_UPDATER_PUBLIC_KEY: ${{ secrets.TAURI_UPDATER_PUBLIC_KEY }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node 20 (npm cache)
        uses: actions/setup-node@v4
        with:
          node-version: "20"
          cache: "npm"

      - name: Install Linux system dependencies (Tauri/WebKitGTK/libsoup2)
        if: runner.os == 'Linux'
        shell: bash
        run: |
          set -euxo pipefail
          sudo apt-get update
          sudo apt-get install -y --no-install-recommends \
            build-essential \
            pkg-config \
            libssl-dev \
            libgtk-3-dev \
            libwebkit2gtk-4.0-dev \
            libsoup2.4-dev \
            libjavascriptcoregtk-4.0-dev \
            libappindicator3-dev \
            librsvg2-dev \
            patchelf \
            curl \
            wget \
            file
          pkg-config --modversion libsoup-2.4
          pkg-config --modversion webkit2gtk-4.0

      - name: Disable DMG bundling on macOS (ship zipped .app + updater artifacts)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euo pipefail
          CONF=""
          if [ -f "src-tauri/tauri.conf.json" ]; then CONF="src-tauri/tauri.conf.json"; fi
          if [ -f "src-tauri/tauri.conf.json5" ]; then CONF="src-tauri/tauri.conf.json5"; fi
          if [ -z "$CONF" ]; then
            echo "No tauri.conf.json/json5 found; skipping patch."
            exit 0
          fi
          echo "Patching $CONF to disable DMG (set bundle.targets to [\"app\", \"updater\"])."
          # Best-effort patch that works for common JSON/JSON5 shapes without requiring json5 tooling:
          # 1) If targets is an array, replace its contents with app + updater
          # 2) If targets is a string (e.g., "all"), set it to ["app", "updater"]
          perl -0777 -i -pe '
            s/"targets"\s*:\s*\[[^\]]*\]/"targets": ["app", "updater"]/g;
            s/"targets"\s*:\s*"all"/"targets": ["app", "updater"]/g;
            s/"targets"\s*:\s*"dmg"/"targets": ["app", "updater"]/g;
          ' "$CONF"

      - name: Setup Rust (stable) + target
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Validate updater signing secrets
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${TAURI_PRIVATE_KEY:-}" ]; then
            echo "Missing TAURI_PRIVATE_KEY secret. Updater bundles require signing."
            exit 1
          fi
          if [ -z "${TAURI_UPDATER_PUBKEY:-}${TAURI_UPDATER_PUBLIC_KEY:-}" ]; then
            echo "Missing TAURI_UPDATER_PUBKEY/TAURI_UPDATER_PUBLIC_KEY secret. Release binaries must embed updater pubkey."
            exit 1
          fi

      - name: Normalize updater keys for release build
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p .tauri-ci
          node <<'NODE'
          const fs = require("fs");
          const crypto = require("crypto");
          const confPath = "src-tauri/tauri.conf.json";

          const stripWrapping = (input) => {
            let s = String(input || "").trim();
            if (
              (s.startsWith('"') && s.endsWith('"')) ||
              (s.startsWith("'") && s.endsWith("'")) ||
              (s.startsWith("`") && s.endsWith("`"))
            ) {
              s = s.slice(1, -1).trim();
            }
            return s;
          };

          const decodeUriSafely = (input) => {
            const safeInput = String(input || "").replace(/%(?![0-9A-Fa-f]{2})/g, "%25");
            try {
              return decodeURIComponent(safeInput);
            } catch {
              return input;
            }
          };

          const normalizeText = (input) => {
            let s = stripWrapping(input);
            s = s.replace(/\\r\\n/g, "\n").replace(/\\n/g, "\n").replace(/\\r/g, "\n");
            s = decodeUriSafely(s);
            return stripWrapping(s).trim();
          };

          const normalizeBase64 = (input) => {
            const compact = String(input || "").replace(/\s+/g, "");
            if (!compact) return "";
            const standard = compact.replace(/-/g, "+").replace(/_/g, "/");
            if (!/^[A-Za-z0-9+/=]+$/.test(standard)) return "";
            const rem = standard.length % 4;
            if (rem === 1) return "";
            return rem === 0 ? standard : `${standard}${"=".repeat(4 - rem)}`;
          };

          const decodeBase64IfClear = (input) => {
            let value = normalizeText(input);
            const dataUri = value.match(/^data:[^,]*;base64,(.+)$/i);
            if (dataUri) value = dataUri[1].trim();
            const marker = value.match(/^base64[:,](.+)$/i);
            if (marker) value = marker[1].trim();
            if (!/^[A-Za-z0-9+/_=\s-]+$/.test(value)) return "";
            const normalized = normalizeBase64(value);
            if (!normalized) return "";
            try {
              const decoded = normalizeText(Buffer.from(normalized, "base64").toString("utf8"));
              if (!decoded) return "";
              if (!/(?:^|\n)\s*untrusted comment:|RW[A-Za-z0-9+/_=-]{20,}/i.test(decoded)) return "";
              return decoded;
            } catch {
              return "";
            }
          };

          const buildCandidates = (raw) => {
            const seen = new Set();
            const out = [];
            const push = (value) => {
              const normalized = normalizeText(value);
              if (!normalized || seen.has(normalized)) return;
              seen.add(normalized);
              out.push(normalized);
            };
            push(raw);
            push(decodeUriSafely(raw));
            for (const candidate of [...out]) {
              push(decodeBase64IfClear(candidate));
            }
            for (const candidate of [...out]) {
              push(decodeBase64IfClear(candidate));
            }
            return out.slice(0, 12);
          };

          const parsePublicKeyBox = (candidate) => {
            const lines = normalizeText(candidate)
              .split(/\r?\n/)
              .map((line) => line.trim())
              .filter(Boolean);
            const rwLine =
              lines.find((line) => /^RW[A-Za-z0-9+/_=-]{20,}$/.test(line)) ||
              (normalizeText(candidate).match(/RW[A-Za-z0-9+/_=-]{20,}/) || [])[0] ||
              "";
            if (!rwLine) return null;

            const normalizedRwLine = normalizeBase64(rwLine);
            if (!normalizedRwLine || !/^RW[A-Za-z0-9+/=]+$/.test(normalizedRwLine)) return null;

            const commentLine =
              lines.find((line) => /^untrusted comment:\s*.+$/i.test(line)) ||
              "untrusted comment: minisign public key";

            return {
              decoded: `${commentLine}\n${normalizedRwLine}`,
              rwLine: normalizedRwLine,
            };
          };

          const parsePrivateKeyBlock = (candidate) => {
            const lines = normalizeText(candidate)
              .split(/\r?\n/)
              .map((line) => line.trim())
              .filter(Boolean);
            for (let i = 0; i < lines.length; i += 1) {
              const comment = lines[i];
              if (!/^untrusted comment:\s*(?:mini|r)sign(?:\s+encrypted)?\s+secret key:?$/i.test(comment)) {
                continue;
              }
              const keyLine = lines.slice(i + 1).find((line) => /^RW[A-Za-z0-9+/_=-]{20,}$/.test(line));
              if (!keyLine) continue;
              const normalizedKeyLine = normalizeBase64(keyLine);
              if (!normalizedKeyLine || !normalizedKeyLine.startsWith("RW")) continue;
              const commentType = /rsign/i.test(comment)
                ? "rsign"
                : /minisign/i.test(comment)
                  ? "minisign"
                  : "unknown";
              return {
                decoded: `${comment}\n${normalizedKeyLine}`,
                commentType,
              };
            }
            return null;
          };

          const shortHash = (value) =>
            crypto.createHash("sha256").update(String(value || ""), "utf8").digest("hex").slice(0, 16);

          const rawPub = process.env.TAURI_UPDATER_PUBKEY || process.env.TAURI_UPDATER_PUBLIC_KEY || "";
          const pubCandidates = buildCandidates(rawPub);
          const parsedPub = pubCandidates.map(parsePublicKeyBox).find(Boolean) || null;
          if (!parsedPub) {
            const preview = normalizeText(rawPub).slice(0, 48);
            throw new Error(
              `Could not parse updater pubkey. Expected minisign public key line starting with RW. Got prefix: "${preview}".`
            );
          }
          const pubRw = parsedPub.rwLine;
          const pubDecoded = parsedPub.decoded;
          const pubEncoded = Buffer.from(pubDecoded, "utf8").toString("base64");

          const rawPriv = process.env.TAURI_PRIVATE_KEY || "";
          const privCandidates = buildCandidates(rawPriv);
          const parsedPriv = privCandidates.map(parsePrivateKeyBlock).find(Boolean) || null;
          if (!parsedPriv) {
            throw new Error("Could not parse TAURI_PRIVATE_KEY into minisign/rsign secret key content.");
          }
          const privDecoded = parsedPriv.decoded;
          const privCommentType = parsedPriv.commentType;
          const privEncoded = Buffer.from(privDecoded, "utf8").toString("base64");

          const envFile = process.env.GITHUB_ENV;
          if (!envFile) {
            throw new Error("GITHUB_ENV is not set; cannot export normalized TAURI_PRIVATE_KEY.");
          }
          fs.appendFileSync(envFile, `TAURI_PRIVATE_KEY=${privEncoded}\n`, "utf8");

          const config = JSON.parse(fs.readFileSync(confPath, "utf8"));
          config.tauri = config.tauri || {};
          config.tauri.updater = config.tauri.updater || {};
          config.tauri.updater.pubkey = pubEncoded;
          fs.writeFileSync(confPath, `${JSON.stringify(config, null, 2)}\n`, "utf8");
          console.log("Normalized updater key material and injected updater pubkey.");
          console.log(`[diag] updater pubkey matches ^RW: ${/^RW[A-Za-z0-9+/=]+$/.test(pubRw)}`);
          console.log(`[diag] updater pubkey rw length: ${pubRw.length}, sha256: ${shortHash(pubRw)}`);
          console.log(`[diag] updater pubkey decoded length: ${pubDecoded.length}, sha256: ${shortHash(pubDecoded)}`);
          console.log(`[diag] updater pubkey encoded length: ${pubEncoded.length}, sha256: ${shortHash(pubEncoded)}`);
          console.log(`[diag] private key comment type: ${privCommentType}`);
          console.log(`[diag] private key decoded length: ${privDecoded.length}, sha256: ${shortHash(privDecoded)}`);
          console.log(`[diag] private key encoded length: ${privEncoded.length}, sha256: ${shortHash(privEncoded)}`);
          NODE

      - name: Rust cache
        uses: Swatinem/rust-cache@v2
        with:
          workspaces: |
            src-tauri -> target

      - name: Install JS deps
        run: npm ci

      - name: Build (Tauri)
        shell: bash
        run: |
          set -euxo pipefail
          npm run tauri:build -- --target ${{ matrix.target }}

      - name: Ad-hoc sign macOS app (avoids "damaged" warning)
        if: runner.os == 'macOS'
        shell: bash
        run: |
          set -euxo pipefail
          BUNDLE_DIR="src-tauri/target/${{ matrix.target }}/release/bundle/macos"

          echo "Looking for .app in: $BUNDLE_DIR"
          ls -la "$BUNDLE_DIR" || true

          APP="$(ls -d "$BUNDLE_DIR"/*.app 2>/dev/null | head -n 1)"
          if [ -z "${APP:-}" ]; then
            echo "No .app found at expected path."
            echo "Searching bundle dir for any .app..."
            find "src-tauri/target/${{ matrix.target }}/release/bundle" -maxdepth 4 -name "*.app" -print || true
            exit 1
          fi

          echo "Signing: $APP"
          codesign --force --deep --sign - "$APP"
          codesign --verify --deep --strict "$APP"


      - name: Collect release artifacts
        shell: bash
        run: |
          set -euxo pipefail
          mkdir -p dist-artifacts

          TAG="${GITHUB_REF_NAME}"
          LABEL="${{ matrix.label }}"

          BUNDLE_DIR_1="src-tauri/target/${{ matrix.target }}/release/bundle"
          BUNDLE_DIR_2="src-tauri/target/release/bundle"

          pick_bundle_dir() {
            if [ -d "$BUNDLE_DIR_1" ]; then echo "$BUNDLE_DIR_1"; return; fi
            if [ -d "$BUNDLE_DIR_2" ]; then echo "$BUNDLE_DIR_2"; return; fi
            local found
            found="$(find "src-tauri/target" -type d -path "*/release/bundle" | head -n 1 || true)"
            if [ -n "$found" ]; then echo "$found"; return; fi
            echo ""
          }

          BUNDLE_DIR="$(pick_bundle_dir)"
          if [ -z "$BUNDLE_DIR" ]; then
            echo "Could not find Tauri bundle directory."
            echo "Tried: $BUNDLE_DIR_1 and $BUNDLE_DIR_2"
            exit 1
          fi

          echo "Using bundle dir: $BUNDLE_DIR"

          shopt -s nullglob
          sanitize_name() {
            printf '%s' "$1" | tr ' ' '-' | tr -cs '[:alnum:]._-' '-'
          }
          pick_first_file() {
            for f in "$@"; do
              if [ -f "$f" ]; then
                echo "$f"
                return 0
              fi
            done
            return 1
          }
          asset_platform_label() {
            case "$LABEL" in
              macos-arm64) echo "macos-apple-silicon" ;;
              macos-intel) echo "macos-intel" ;;
              windows) echo "windows-x64" ;;
              windows-arm64) echo "windows-arm64" ;;
              linux) echo "linux-x64" ;;
              *) echo "$LABEL" ;;
            esac
          }

          ASSET_PLATFORM="$(asset_platform_label)"
          PREFIX="openjar-launcher_${TAG}_${ASSET_PLATFORM}"
          INSTALLER_PREFIX="OpenJar-Launcher_${TAG}_${ASSET_PLATFORM}"

          if [ "${{ runner.os }}" = "macOS" ]; then
            APPS=("$BUNDLE_DIR/macos/"*.app)
            if [ "${#APPS[@]}" -lt 1 ]; then
              echo "No .app found in $BUNDLE_DIR/macos"
              find "$BUNDLE_DIR" -maxdepth 4 -type d -name "*.app" -print || true
              exit 1
            fi
            APP="${APPS[0]}"
            OUT_NAME="$(sanitize_name "${INSTALLER_PREFIX}_installer.zip")"
            OUT="dist-artifacts/${OUT_NAME}"
            ditto -c -k --sequesterRsrc --keepParent "$APP" "$OUT"
            echo "Created: $OUT"
          elif [ "${{ runner.os }}" = "Windows" ]; then
            installer="$(pick_first_file "$BUNDLE_DIR"/nsis/*.exe "$BUNDLE_DIR"/windows/*.exe || true)"
            if [ -z "${installer:-}" ]; then
              echo "Missing Windows installer (.exe) in $BUNDLE_DIR"
              find "$BUNDLE_DIR" -maxdepth 4 -type f -name "*.exe" -print || true
              exit 1
            fi
            out_name="$(sanitize_name "${INSTALLER_PREFIX}_installer.exe")"
            cp -f "$installer" "dist-artifacts/${out_name}"
          else
            installer="$(pick_first_file "$BUNDLE_DIR"/appimage/*.AppImage || true)"
            if [ -z "${installer:-}" ]; then
              echo "Missing Linux installer (.AppImage) in $BUNDLE_DIR"
              find "$BUNDLE_DIR" -maxdepth 4 -type f -name "*.AppImage" -print || true
              exit 1
            fi
            out_name="$(sanitize_name "${INSTALLER_PREFIX}_installer.AppImage")"
            cp -f "$installer" "dist-artifacts/${out_name}"
          fi

          updater=""
          updater_sig=""
          if [ "${{ runner.os }}" = "macOS" ]; then
            updater="$(pick_first_file "$BUNDLE_DIR"/macos/*.app.tar.gz || true)"
            [ -n "${updater:-}" ] && updater_sig="${updater}.sig"
            updater_ext="tar.gz"
          elif [ "${{ runner.os }}" = "Windows" ]; then
            updater="$(pick_first_file "$BUNDLE_DIR"/msi/*.msi.zip "$BUNDLE_DIR"/windows/*.msi.zip || true)"
            [ -n "${updater:-}" ] && updater_sig="${updater}.sig"
            updater_ext="zip"
          else
            updater="$(pick_first_file "$BUNDLE_DIR"/appimage/*.AppImage.tar.gz || true)"
            [ -n "${updater:-}" ] && updater_sig="${updater}.sig"
            updater_ext="tar.gz"
          fi

          if [ -z "${updater:-}" ] || [ ! -f "$updater" ]; then
            echo "Missing updater archive in $BUNDLE_DIR"
            find "$BUNDLE_DIR" -maxdepth 4 -type f \( -name "*.tar.gz" -o -name "*.zip" \) -print || true
            exit 1
          fi
          if [ -z "${updater_sig:-}" ] || [ ! -f "$updater_sig" ]; then
            echo "Missing updater signature for $updater"
            find "$BUNDLE_DIR" -maxdepth 4 -type f -name "*.sig" -print || true
            exit 1
          fi

          updater_out="$(sanitize_name "${PREFIX}_auto-update-only_updater.${updater_ext}")"
          updater_sig_out="${updater_out}.sig"
          cp -f "$updater" "dist-artifacts/${updater_out}"
          cp -f "$updater_sig" "dist-artifacts/${updater_sig_out}"

          # Sanity: only keep real distributables
          find dist-artifacts -type f \
            ! -name "*.dmg" \
            ! -name "*.zip" \
            ! -name "*.tar.gz" \
            ! -name "*.AppImage" \
            ! -name "*.deb" \
            ! -name "*.rpm" \
            ! -name "*.msi" \
            ! -name "*.exe" \
            ! -name "*.sig" \
            -delete || true

          echo "Final artifacts:"
          ls -la dist-artifacts
          test -n "$(ls -A dist-artifacts)"

      - name: Upload workflow artifacts
        uses: actions/upload-artifact@v4
        with:
          name: release-${{ matrix.label }}
          path: dist-artifacts/*
          if-no-files-found: error
          retention-days: 7

  publish:
    name: Publish GitHub Release
    runs-on: ubuntu-latest
    needs: build
    if: startsWith(github.ref, 'refs/tags/v')

    steps:
      - name: Download all build artifacts
        uses: actions/download-artifact@v4
        with:
          path: release-assets

      - name: List assets
        shell: bash
        run: |
          set -euxo pipefail
          find release-assets -type f -maxdepth 3 -print
          test -n "$(find release-assets -type f -maxdepth 3 -print -quit)"

      - name: Generate latest.json updater manifest
        shell: bash
        run: |
          set -euo pipefail
          node -e 'const fs=require("fs"); const path=require("path"); const root="release-assets"; const repo=process.env.GITHUB_REPOSITORY; const tag=process.env.GITHUB_REF_NAME; if(!repo||!tag){ throw new Error("Missing GITHUB_REPOSITORY or GITHUB_REF_NAME"); } const version=tag.startsWith("v")?tag.slice(1):tag; const walk=(dir)=>{ const out=[]; for (const item of fs.readdirSync(dir,{withFileTypes:true})) { const full=path.join(dir,item.name); if(item.isDirectory()) out.push(...walk(full)); else if(item.isFile()) out.push(full); } return out; }; const files=walk(root).map((full)=>path.relative(root,full).replace(/\\\\/g,"/")); const updaterArchives=files.filter((f)=>/_auto-update-only_updater\.(tar\.gz|zip)$/.test(path.basename(f))); const platforms={}; const platformMap={ "macos-apple-silicon":"darwin-aarch64", "macos-intel":"darwin-x86_64", "windows-arm64":"windows-aarch64", "windows-x64":"windows-x86_64", "linux-x64":"linux-x86_64" }; const pattern=/^openjar-launcher_v[^_]+_(macos-apple-silicon|macos-intel|windows-arm64|windows-x64|linux-x64)_auto-update-only_updater\.(tar\.gz|zip)$/; for (const archive of updaterArchives) { const fileName=path.basename(archive); const match=fileName.match(pattern); if(!match) continue; const platform=platformMap[match[1]]; if(!platform) continue; const sigPath=archive+".sig"; const fullSig=path.join(root,sigPath); if(!fs.existsSync(fullSig)) continue; const signature=fs.readFileSync(fullSig,"utf8").trim(); if(!signature) continue; const encodedFileName=encodeURIComponent(fileName); platforms[platform]={ signature, url:"https://github.com/"+repo+"/releases/download/"+tag+"/"+encodedFileName }; } if (Object.keys(platforms).length===0) { throw new Error("No signed updater artifacts found for latest.json generation."); } const manifest={ version, notes:"OpenJar Launcher "+tag, pub_date:new Date().toISOString(), platforms }; const outPath=path.join(root,"latest.json"); fs.writeFileSync(outPath, JSON.stringify(manifest,null,2)+"\\n","utf8"); console.log("Wrote "+outPath); console.log(JSON.stringify(manifest,null,2));'

      - name: Create/Update GitHub Release and upload assets
        uses: softprops/action-gh-release@v2
        with:
          tag_name: ${{ github.ref_name }}
          generate_release_notes: true
          fail_on_unmatched_files: true
          files: |
            release-assets/**/OpenJar-Launcher_*_installer.*
            release-assets/**/openjar-launcher_*_updater.*
            release-assets/latest.json
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
